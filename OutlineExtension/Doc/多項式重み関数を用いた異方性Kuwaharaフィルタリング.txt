多項式重み関数を用いた異方性Kuwaharaフィルタリング

1. 序論
**非写実的レンダリング（Non-Photorealistic Rendering：NPR）**の分野において、古典的な研究テーマのひとつが、エッジを保持する平滑化および強調フィルターを用いた写真のスタイライズ化と抽象化です。
この分野でよく知られた手法に共通するのは、低コントラストな領域のディテールを除去しつつ、画像内のエッジ（不連続性）を越えてのフィルタリングは行わず、入力画像の全体的な構造を保つという点です。
代表的な例としては、バイラテラルフィルタ [WOG06, KD08, KLC09] や 平均値シフト法（Mean Shift） [CM02, DS02] などがあります。
この分野でもうひとつの有名なフィルターが、Kuwahara フィルター [KHEK76] です。
このフィルターの基本的なアイデアは、フィルターカーネルを4つの長方形のサブ領域に分割することにあります。
これらのサブ領域は 1ピクセル分重なるように配置されます。
フィルターの出力は、分散（バリエーション）が最小のサブ領域の平均値として定義されます。
ただし、Kuwahara フィルターには**明確に視認できるアーティファクト（不自然な処理の痕跡）**が生じます。
これは、長方形のサブ領域を用いていることに起因しています。
さらに、ノイズがある場合や、複数のサブ領域の分散が同じである場合には、
どのサブ領域を選ぶかが不安定になり、ランダムな選択とそれに伴うアーティファクトが発生します。
Kuwahara フィルターの制限についての詳細な議論は [PPC07] に記載されています。

　Kuwahara フィルターの制限に対処するために、これまでにいくつかの試みが行われてきました。
[PPC07] では、不安定なサブ領域選択処理の制限を克服するための新しい基準が定義されています。
1つのサブ領域を選択する代わりに、すべてのサブ領域の平均値の重み付き和によって結果を定義します。
重みは、各サブ領域の分散に基づいて定義されます。
この方法により、領域境界はより滑らかになり、アーティファクトも少なくなります。
さらに改善を図るために、長方形のサブ領域を、円盤内のセクター上に定義された滑らかな重み関数に置き換えています。

　異方性 Kuwahara フィルター [KKD09] は、[PPC07] による一般化 Kuwahara フィルタリングの概念を基に構築され、
円盤のセクター上に定義された重み関数を、楕円上に定義された重み関数へと置き換えています。
この楕円の形状・スケール・方向を入力画像の局所的な構造に適応させることによって、
アーティファクトを回避し、方向性のある画像特徴をより良く保持・強調できるようになっています。
その結果、全体としてエッジがよりシャープになり、方向性のある画像特徴が際立つようになります。
より詳細な関連研究の議論や他手法との比較については、[KKD09] を参照してください。

　本研究では、異方性 Kuwahara フィルターの改良版を提案します。
我々は、畳み込みに依存しない新しい重み関数を導入します。
そのため、これらの重み関数は 逐次計算に適しており、リアルタイムでの処理が可能です。
さらに、提案された重み関数はパラメータ化可能です。
**離心率（eccentricity）や拡張度（expansion）**を調整することで、隣接するセクターとの重なり具合を制御することが可能になります。



2. 異方性 Kuwahara フィルタリング
画像の局所構造に合わせてフィルタ形状を適応させるために、異方性 Kuwahara フィルタは、局所的な方向情報と、異方性の度合いを示す指標を必要とします。
これらは、平滑化された構造テンソルの固有値と固有ベクトルから導出することができます [BBL06]。
・**局所的な方向（オリエンテーション）**は、**小さい方の固有ベクトルの偏角（角度）**によって与えられ、
・**異方性の度合い（Anisotropy A）**は、大きい方と小さい方の固有値から算出されます [YBFU96]。

異方性 A は 0～1 の範囲を取り、
・A=0 のときは「等方的（全方向に均一）」、
・A=1 のときは「完全に異方的（方向に依存する構造）」な領域を意味します。

関数 f:R 2 →R 3 を入力画像、
点(x 0 ,y 0)∈R 2 を注目する位置とし、
φ をその位置での局所方向、A を異方性とします。

異方性に応じてフィルタの**楕円形状の離心率（eccentricity）**を調整するために、次のように設定します：
・r：フィルタの基準半径
・α>0：調整パラメータ（通常は α=1）
このとき、A∈[0,1] より：
・r≤a≤2r、
・r/2≤b≤r
が成り立ちます（ここで a,b は楕円の長短半径）。

また、角度 φ による回転を定義する回転行列 R φ を導入し、
写像 SR φ は、回転された楕円を単位円へ写す線形座標変換になります（図3参照）。
異方性 Kuwahara フィルタは、この楕円を元のフィルタと同様に複数のセクターに分割して処理を行います。

セクター分割と重み関数
・セクター数 N（典型的には N=4 または N=8）
・セクターは互いに重なり合う必要がある
そのために、各ピクセルがどのセクターにどれだけ影響を与えるかを定める重み関数を使用します。

楕円上でこれらの重み関数を定義するために、まず**単位円上に対応する重み関数を定義し、それを楕円に引き戻す（pull back）**という手法をとります。
たとえば、特性関数 χ 0 を、偏角が [−π/N,π/N] の範囲にある点で 1、それ以外で 0 となる関数とします。

これにより、単位円上に滑らかな重み関数が定義されます。
・G θ​ ,G σ ：ガウス関数
・∗：畳み込み演算（convolution）
まず特性関数をガウス関数で畳み込み、隣接するセクターからの影響も考慮できるように滑らかにします。
その後、さらに別のガウス関数を乗算することで、半径が大きくなるにつれて重みが減衰するようにします（図4）。

妥当なパラメータの例：
・σ=0.4、
・θ=σ/3

その他のセクターの重み関数も、対応する特性関数を畳み込みするか、単に回転することで定義できます。
関数合成記号 ∘（例：f∘g）を使って、すべてのセクターに対して滑らかな重み関数 K i を定義できます。
それを楕円に引き戻すことで、最終的な重み関数 w i が得られます（図5参照）。

フィルター出力の定義
図6は、異方性 Kuwahara フィルタが局所の方向・異方性に基づく楕円を用いて重みを定義する様子を示しています。
このフィルタの出力は、以下のように計算されます：
各セクターに対して：
・局所平均値（ピクセル群の平均）
・分散の二乗（標準偏差の二乗）
・正規化係数（重みの合計）

これらを使って、標準偏差が小さいセクター（＝均質な領域）に大きな重みが与えられるような重み係数 α i を定義します（図6）。
この重み付き平均によって、ノイズに強く、エッジを保持しながら滑らかな出力が得られます。
パラメータ q はシャープネスの調整に用いられ、通常は q=8 に設定されます。



3. 代替の重み関数
重み関数 w i は画像の局所構造に適応するように設計されているため、画素ごとに異なる形状を持ちます。
したがって、式 (1) および (2) にある畳み込み演算を周波数領域で行うことは不可能です。
そのため、計算は**空間領域（spatial domain）**で行う必要があります。
この処理を効率よく実装するには、重み関数 K i を迅速に評価できる必要があります。

しかし、K i を直接計算しようとすると、畳み込みを必要とするため非現実的です。
そこで [KKD10] では、K 0 ,K 1 ,K 2 ,K 3 をRGBA テクスチャマップにサンプリングして保存しています。
このテクスチャマップを使えば、重みは：
・N=4 の場合は1回のテクスチャ参照で、
・N=8 の場合は2回のテクスチャ参照で
取得可能となります。

本研究では、これとは異なるアプローチを採用しています。
K i を離散化したり近似したりする代わりに、より計算が簡単な別の関数に置き換えることを目指します。

構造上、∑ i K i =G σ （ガウス関数）となるため、
K i はガウス関数 G σ を滑らかに分割する関数と解釈できます。
提案する新たな重み関数もこの性質を持ち、その構成は図7に示されています。

重み関数の構成
基礎となるのは、多項式 (x+δ) λ y 2 です（図7(a) 参照）。
・赤い放物線は、この多項式の**ゼロ交差（ゼロクロッシング）**を示しています。
・負の値を 0 にクリップ（clamp） すると、放物線の内側では非ゼロ、外側ではゼロの関数になります。
・この関数を2乗することで、ゼロ交差点での滑らかな遷移を実現できます（図7(c) 参照）。

このようにして、リアルタイム計算が可能な代替重み関数が構成されます。
数式の複雑さを抑えながらも、ガウス関数を滑らかに分割する性質を維持しています。


他のセクターに対応する関数は、関数 k Q の回転により定義されます。

k i を正規化し、ガウス関数 G σ と乗算することで、単位円上に定義された重み関数が得られます。

期待通り、構成上 ∑j Kzi=Gσ が成り立ち、新しい重み関数 w z i は前節と同様に次のように定義されます：

関数 k Q 0 の定義には、2つのパラメータ δ と λ が含まれています。
パラメータ δ は、フィルターの中心において異なる重み関数がどの程度重なり合うかを制御します。
異方性 Kuwahara フィルターが期待通りに機能するためには、すべての重み関数が互いに境界で、特にフィルターの中心で重なり合っている必要があります。
前のセクションで述べたように、α=1 の場合、楕円の短軸（minor radius）は半径の半分より小さくならないことが保証されます。

これは、すべてのセクターがフィルターの中心で重なり合うことを保証する妥当な定義です。
パラメータ λ は、セクター同士がその側面（境界）でどの程度重なり合うかを制御します。
パラメータ δ および λ が与えられたとき、多項式 (x+δ) λ y 2  のゼロ交差（ゼロクロッシング）の位置を観察することができます（図8参照）。
逆に、ゼロクロッシングが単位円と交差する位置から、δ に基づいて λ を定義することも可能です。

関数 K z i が単位円上で適切に定義されるためには、単位円内のすべての点において、関数の和 ∑ j​ K z i がゼロでない（非ゼロ）ことが必要です。
この条件は、図8の青いグラフのように、セクター数 N を適切に選ぶことで達成できます。

一方で、一つの位置に3つ以上のセクターが重なるのは望ましくありません。
この重なりを避けるためのおおよその上限は 2π  です（図8の緑のグラフを参照）。
したがって、パラメータ λ に対する妥当な選択範囲は以下のようになります：

リスト1は、提案された重み関数を N=8 の場合に効率的に実装する方法を示しています。
ここで重要なのは、max 関数を使用することです。
GPU上ではこの関数は**一般に組み込み関数（intrinsic function）**として提供されており、分岐処理（branching）を伴わないため、非常に高速に実行されます。
N=8 の場合、ベクトル v は π/4（＝45度）回転させる必要があります。
π/2 の倍数による回転は、座標の入れ替えと符号反転によって簡単に実装可能なため、計算は2段階に分けて行われます。
1. 最初に、0, π/2, π, 3π/2 に対応する重みを計算します。
2. その後、π/4 回転を行い、π/4, 3π/4, 5π/4, 7π/4 に対応する重みを計算します。



4. 考察
図2 では、提案された重み関数を用いた異方性 Kuwahara フィルターで処理された画像が示されています。
その結果は、元の重み関数を使用した異方性 Kuwahara フィルターの出力と視覚的に見分けがつかないほどです。
図9(b) に見られるように、提案手法は、特徴を保持し、方向性を強調する見た目を、元のテクスチャベースの実装と同様に生成しています。
図9(c) のように、高コントラスト領域ではわずかな違いが見られます。
しかしこれは、両者のフィルターが完全には一致していないため、驚くことではありません。
本フィルターの主目的は**抽象化（アブストラクション）**であるため、こうした微細な違いはまったく問題になりません。
むしろこのことは、提案手法が [KKD09] で述べられた元の実装の重要な特性を共有していることを示しています。
たとえば：
・低コントラスト領域での過剰なぼかしを防ぐこと（図10(b)）
・高コントラストノイズに対する堅牢性（図10(d)）
といった特徴が挙げられます。

我々はまた、提案手法を動画に適用する実験も行いました。
各フレーム単体でのフィルタリングであっても、優れた時間的整合性（テンポラルコヒーレンス）を実現できています。
なお、本実装は [KKD10] による 異方性 Kuwahara フィルターの GLSL リファレンス実装をベースにしています。

実行時間の比較
表1 は、提案手法とテクスチャベース実装の実行時間を比較したものです。
テクスチャをルックアップテーブル（LUT）として用いることは、リアルタイムグラフィックスで一般的な高速化手法です。
さらに、現代のコンピュータゲームではテクスチャマッピングが多用されており、GPUハードウェアベンダーもこれを前提に最適化を行っています。
しかし、現代のGPUではメモリアクセスが大きなボトルネックとなっています。
これは次世代 DirectX 11 ハードウェアにおいて特に顕著です。
そのため、N=8 の場合、各カーネル要素に対して2回のテクスチャ参照が必要となるテクスチャベース手法よりも、提案手法の方が大幅に高性能です。
一方で、DirectX 10 世代のハードウェアでは、テクスチャベース手法の方がわずかに高速です。

将来的な拡張性
本手法は、GPU上でのさらなる最適化の可能性も持っています。
たとえば、CUDA や OpenCL といった GPUコンピューティングAPI を用いれば、
GPU制御をより細かく行い、共有メモリ（shared memory）などの高度な機能も活用可能です。
ガウス平滑化においては、共有メモリ実装がテクスチャベース実装を上回る性能を示したという報告もあります [Pod07]。
したがって、本手法の共有メモリ実装でも同様の結果が期待できると考えています。



5. 結論
本研究では、異方性 Kuwahara フィルタのための代替重み関数を提案しました。
提案された重み関数は、畳み込みを必要とせず、フィルタ処理中に直接かつ効率的に計算することができます。
本手法により、異方性 Kuwahara フィルタのテクスチャベース実装と同等の品質の出力が得られます。
また、重み関数をフィルタリング処理中に明示的に計算しているにもかかわらず、
8セクターを使用した場合には、次世代GPU上でより高い性能を発揮することが確認されました。
提案された重み関数は、Kuwahara フィルタのさらなる一般化にも貢献しています。
重みが逐次（オン・ザ・フライ）計算されることで、スムージング処理をリアルタイムに、かつインタラクティブまたは自動的に制御するための新たな可能性を提供します。