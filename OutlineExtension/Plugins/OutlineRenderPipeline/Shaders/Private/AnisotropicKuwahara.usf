#include "/Engine/Private/Common.ush"



//
// AnisoKuwaharaEigenvectorパス(固有ベクトルを求めている？構造テンソルの計算？)
//
Texture2D<float4> eigenvectorpass_SourceTexture;
RWTexture2D<float4> eigenvectorpass_OutputTexture;

[numthreads(THREADGROUPSIZE_X,THREADGROUPSIZE_Y,THREADGROUPSIZE_Z)]
void AnisoKuwaharaEigenvectorCS(uint2 DTid : SV_DispatchThreadID)
{
	const float2 pixel_pos = DTid.xy + float2(0.5, 0.5);

	const float3 f00 = eigenvectorpass_SourceTexture.Load(int3(DTid.xy + int2(-1, -1), 0)).xyz;
	const float3 f10 = eigenvectorpass_SourceTexture.Load(int3(DTid.xy + int2(0, -1), 0)).xyz;
	const float3 f20 = eigenvectorpass_SourceTexture.Load(int3(DTid.xy + int2(1, -1), 0)).xyz;

	const float3 f01 = eigenvectorpass_SourceTexture.Load(int3(DTid.xy + int2(-1, 0), 0)).xyz;
	const float3 f21 = eigenvectorpass_SourceTexture.Load(int3(DTid.xy + int2(1, 0), 0)).xyz;
		
	const float3 f02 = eigenvectorpass_SourceTexture.Load(int3(DTid.xy + int2(-1, 1), 0)).xyz;
	const float3 f12 = eigenvectorpass_SourceTexture.Load(int3(DTid.xy + int2(0, 1), 0)).xyz;
	const float3 f22 = eigenvectorpass_SourceTexture.Load(int3(DTid.xy + int2(1, 1), 0)).xyz;

	// sobel.
	// TODO : 4は何の平均を出している？
	const float3 sx = ((1.0*f20 + 2.0*f21 + 1.0*f22) - (1.0*f00 + 2.0*f01 + 1.0*f02)) / 4.0;
	const float3 sy = ((1.0*f02 + 2.0*f12 + 1.0*f22) - (1.0*f00 + 2.0*f10 + 1.0*f20)) / 4.0;

	//
	// gijの計算
	// 構造テンソル(局所的な勾配情報を統合する2×2の対称行列)
	//
	const float exx = dot(sx, sx); // E
	const float exy = dot(sx, sy); // F
	const float eyy = dot(sy, sy); // G
	
	eigenvectorpass_OutputTexture[DTid.xy] = float4(exx, eyy, exy, 1);
}

//
// BlurPass_CS
//
float GaussFunction(float sigma, float r)
{
	const float PI = 3.14159265;
	//
	// Gσの計算
	// [P4]論文にあるガウスフィルタの計算( https://www.kyprianidis.com/p/pg2009/jkyprian-pg2009.pdf )
	// ※微分
	// return (1.0f / sqrt(2.0f * PI * sigma * sigma)) * exp(-(r * r) / (2.0f * sigma * sigma));
	return (1.0f / sqrt(2.0f * PI * sigma * sigma)) * exp(- pow(r, 2) / (2.0f * sigma * sigma));

	// 実験中 : Unityの構文に合わせる
	// float x = (float)(i - RADIUS);
	// float g = exp(-x * x / (2.0 * sigma * sigma));
	// return exp(-r * r / (2.0 * sigma * sigma));
}

Texture2D blurpass_SourceTexture;
RWTexture2D<float4> blurpass_OutputTexture;
uint2 blurpass_OutputDimensions;
int GaussRadius;
float GaussSigma;

[numthreads(THREADGROUPSIZE_X,THREADGROUPSIZE_Y,THREADGROUPSIZE_Z)]
void AnisoKuwaharaBlurCS(
	uint3 Gid	: SV_GroupID,
	uint3 DTid	: SV_DispatchThreadID,
	uint3 GTid	: SV_GroupThreadID,
	uint Gi		: SV_GroupIndex
	)
{
	// TODO : カーネル固定値(上下、左右)
	// const int kernelRadius = 5;
	// Add
	const int kernelRadius = GaussRadius;
	// const float gauss_sigma = GaussSigma;
	// TODO : Test中。gauss_sigma=10の効果が無い。使い方が不明
	const float gauss_sigma = 2.0f;

	const int2 pixel_point = DTid.xy;

	// TODO. 分離可能フィルタへの変更も可能.
	float4 accum_data = (float4)0;
	float  accum_weight = 0;
	for(int j = -kernelRadius; j <= kernelRadius; ++j)
	{
		for(int i = -kernelRadius; i <= kernelRadius; ++i)
		{
			const int2 sample_offset = int2(i,j);
			const float4 sampleL_data = blurpass_SourceTexture.Load(int3(pixel_point + sample_offset, 0));

			// TODO : 元のコード
			// const float g = GaussFunction(2.0, length(sample_offset));
			const float g = GaussFunction(gauss_sigma, length(sample_offset));
			// 実験中
			// const int2 kernel = int2(kernelRadius, kernelRadius);
			// const float g = GaussFunction(gauss_sigma, length(kernel) - length(sample_offset));

			//
			// fxの計算
			// 関数 f の偏導関数の近似
			//
			accum_data += g * sampleL_data;
			accum_weight += g;
		}
	}

	// TODO : 平坦化
	accum_data /= accum_weight;
		
	blurpass_OutputTexture[DTid.xy] = accum_data;
}

//
// Calc Anisotropy.(局所方位と異方性の尺度の計算？)
//
Texture2D calcanisopass_SourceTexture;
RWTexture2D<float4> calcanisopass_OutputTexture;

[numthreads(THREADGROUPSIZE_X,THREADGROUPSIZE_Y,THREADGROUPSIZE_Z)]
void AnisoKuwaharaCalcAnisoCS(
	uint3 Gid	: SV_GroupID,
	uint3 DTid	: SV_DispatchThreadID,
	uint3 GTid	: SV_GroupThreadID,
	uint Gi		: SV_GroupIndex
	)
{
	const int2 pixel_point = DTid.xy;
	
	const float4 eigenvector = calcanisopass_SourceTexture.Load(int3(pixel_point, 0));
	const float E = eigenvector.x; // dot(sx, sx)
	const float G = eigenvector.y; // dot(sy, sy)
	const float F = eigenvector.z; // dot(sy, sy)

	//----------------------------------------------------------
	// λ1,2 の計算
	//----------------------------------------------------------
	// [4P]の右上の上側の式
	const float sqrt_innner_term = (E-G)*(E-G) + 4.0*F*F;
	// [4P]の右上の上側の式
	const float term_sqrt = (1e-4 < sqrt_innner_term)? sqrt( sqrt_innner_term ) : 0.0;
	// [4P]の右上の上側の式
	const float lambda1 = (E + G + term_sqrt) * 0.5;
	const float lambda2 = (E + G - term_sqrt) * 0.5;

	//---------------------------------------------------------
	// Aの計算
	//---------------------------------------------------------
	const float anisotropy = (1e-4 < (lambda1 + lambda2))? (lambda1 - lambda2) / (lambda1 + lambda2) : 0.0;
	//---------------------------------------------------------
	// tの計算
	//---------------------------------------------------------
	const float2 v = float2(lambda1 - E, -F);
	const float2 t = (any(0 < abs(v)))? normalize(v) : float2(0.0f, 1.0f);
	// TODO : atanするのはどこに書いてある？
	const float phi = -atan2(t.y, t.x);
		
	calcanisopass_OutputTexture[DTid.xy] = float4(t.x, t.y, phi, anisotropy);
}


//
// Final.
//
Texture2D finalpass_SourceTexture;
SamplerState finalpass_SourceSampler;
Texture2D finalpass_SceneTexture;
RWTexture2D<float4> finalpass_OutputTexture;

float finalpass_aniso_control; // 1
float finalpass_hardness; // 8
float finalpass_sharpness; // 8

int KuwaharaRadius;
int KuwaharaQ;
float KuwaharaAlpha;

#define k_aniso_kuwahara_section_count 8

[numthreads(THREADGROUPSIZE_X,THREADGROUPSIZE_Y,THREADGROUPSIZE_Z)]
void AnisoKuwaharaFinalCS(
	uint3 Gid	: SV_GroupID,
	uint3 DTid	: SV_DispatchThreadID,
	uint3 GTid	: SV_GroupThreadID,
	uint Gi		: SV_GroupIndex
	)
{
	// TODO : 元コード
	// const int k_kernel_radius = 7;
	// const float k_aniso_param = finalpass_aniso_control;//1.0;
	// Add
	const int k_kernel_radius = KuwaharaRadius;
	const float k_aniso_param = KuwaharaAlpha;
	
	const int2 pixel_point = DTid.xy;

	const float4 aniso_data = finalpass_SourceTexture.Load(int3(pixel_point, 0));
	const float4 cur_color = finalpass_SceneTexture.Load(int3(pixel_point, 0));
	
	const float cos_phi = cos(aniso_data.z);
	const float sin_phi = sin(aniso_data.z);
	const float2x2 R = float2x2(cos_phi, -sin_phi, sin_phi, cos_phi);

	//---------------------------------------------------------
	// Sの計算
	// 異方性によるサンプル距離の最大・最小をクランプ.
	//---------------------------------------------------------
	const float scale_a = k_kernel_radius * clamp((k_aniso_param + aniso_data.w) / k_aniso_param, 0.1, 2.0);
	const float scale_b = k_kernel_radius * clamp(k_aniso_param / (k_aniso_param + aniso_data.w), 0.1, 2.0);
	const float2x2 S = float2x2(1.0/scale_a, 0.0, 0.0, 1.0/scale_b);

	// 異方性方向キャンセルと異方性スケールキャンセルの行列.
	float2x2 SR = mul(S, R);

	const int sample_radius_x = k_kernel_radius;
	const int sample_radius_y = k_kernel_radius;
	
	const float zeta = 2.0 / k_kernel_radius;
	const float gamma = 3.0 * PI / (2.0 * k_aniso_kuwahara_section_count);
	const float eta = (zeta + cos(gamma)) / (sin(gamma)*sin(gamma));
	
	float4 m[k_aniso_kuwahara_section_count];
	float3 s[k_aniso_kuwahara_section_count];
	for (int k = 0; k < k_aniso_kuwahara_section_count; ++k) {
		m[k] = 0.0;
		s[k] = 0.0;
	}
	// 7回ループ
	for(int j = -sample_radius_y; j <= sample_radius_y; ++j)
	{
		for(int i = -sample_radius_x; i <= sample_radius_x; ++i)
		{
			const int2 sample_offset = int2(i, j);
			const float2 normalize_sample_offset = mul(SR, float2(sample_offset));
			
			const float3 sample_color = finalpass_SceneTexture.Load(int3(pixel_point + sample_offset, 0)).xyz;

			// https://github.com/GarrettGunnell/Post-Processing/blob/main/Assets/Kuwahara%20Filter/AnisotropicKuwahara.shader
			float2 v = normalize_sample_offset;
		
			float sum = 0;
            float w[k_aniso_kuwahara_section_count];
            float z, vxx, vyy;

			// フィルターカーネルの計算
            /* Calculate Polynomial Weights */ // 多項式の重みを計算する
			// Unity zeta = 0.33h
			//       eta  = 3.77h
            vxx = zeta - eta * v.x * v.x;
            vyy = zeta - eta * v.y * v.y;
            z = max(0, v.y + vxx); 
            w[0] = z * z;
            sum += w[0];
            z = max(0, -v.x + vyy); 
            w[2] = z * z;
            sum += w[2];
            z = max(0, -v.y + vxx); 
            w[4] = z * z;
            sum += w[4];
            z = max(0, v.x + vyy); 
            w[6] = z * z;
            sum += w[6];
			// Unityと違う
            v = sqrt(2.0f) / 2.0f * float2(v.x - v.y, v.x + v.y);
            vxx = zeta - eta * v.x * v.x;
            vyy = zeta - eta * v.y * v.y;
            z = max(0, v.y + vxx); 
            w[1] = z * z;
            sum += w[1];
            z = max(0, -v.x + vyy); 
            w[3] = z * z;
            sum += w[3];
            z = max(0, -v.y + vxx); 
            w[5] = z * z;
            sum += w[5];
            z = max(0, v.x + vyy); 
            w[7] = z * z;
            sum += w[7];
            
            float g = (0.0 < sum)? exp(-3.125f * dot(v,v)) / sum : 0.0;
            for (int k = 0; k < k_aniso_kuwahara_section_count; ++k)
            {
                float wk = w[k] * g;
            	// Unityでも共通処理
                m[k] += float4(sample_color * wk, wk);
                s[k] += sample_color * sample_color * wk;
            }
		}
	}
	
	const float k_hardness = finalpass_hardness;//256;
	// TODO : 元コード
	// const float k_sharpness = finalpass_sharpness;//8.0;
	float k_sharpness = float(KuwaharaQ);
	
	float4 output = (float4)0;
	for (int k = 0; k < k_aniso_kuwahara_section_count; ++k)
	{
		// Unityと共通処理
		const float weight_div = (0.0 < m[k].w)? 1.0/m[k].w : 0.0;
		m[k].rgb *= weight_div;
		s[k] = abs(s[k] * weight_div - m[k].rgb * m[k].rgb);

		const float sigma2 = s[k].r + s[k].g + s[k].b;
		// Unityだと 『255.0h *』となっている
		const float w = 1.0f / (1.0f + pow( k_hardness * 1000.0 * sigma2, k_sharpness));

		// Unityでお計算方法は同じ
		// Unity : o += w * half4(m[k].rgb, 1.0h);
		output += float4(m[k].rgb * w, w);
	}
	// Unityでお計算方法は同じ
	// Unity : half3(o.rgb / o.w); 
	output.xyz = (0.0 < output.w)? output.xyz/output.w : cur_color.xyz;
	
	finalpass_OutputTexture[DTid.xy] = float4(output.xyz, 0);
}



//
// AIが作成した異方性桑原フィルタ(動かない)
//
// KuwaharaFilterCS.hlsl

// cbuffer FilterParams : register(b0)
// {
//     float2 ImageSize;
//     float2 EllipseA;     // 長軸 (a), 短軸 (b)
//     float Angle;         // 楕円の回転角
//     int NumSectors;      // セクター数（例: 8）
//     float Radius;        // フィルタ半径
//     float Q;             // シャープネスパラメータ（例: 8）
// };

// Texture2D InputTex : register(t0);
// RWTexture2D<float4> OutputTex : register(u0);

float2 ImageSize;
float2 EllipseA;     // 長軸 (a), 短軸 (b)
float Angle;         // 楕円の回転角
int NumSectors;      // セクター数（例: 8）
float Radius;        // フィルタ半径
float Q;             // シャープネスパラメータ（例: 8）

Texture2D InputTex;
RWTexture2D<float4> OutputTex;
SamplerState samplerLinearClamp;

#define PI 3.14159265

// 回転行列を使って楕円空間に変換
float2 Rotate(float2 v, float angle)
{
    float s = sin(angle);
    float c = cos(angle);
    return float2(c * v.x - s * v.y, s * v.x + c * v.y);
}

// ガウス関数
float Gaussian(float2 x, float sigma)
{
    float r2 = dot(x, x);
    return exp(-r2 / (2.0 * sigma * sigma));
}

// 重み関数（セクター分割＋ガウス減衰）
float SectorWeight(float2 dir, float angle, float sectorWidth, float q)
{
    float theta = atan2(dir.y, dir.x);
    float delta = abs(angle - theta);
    delta = min(delta, 2 * PI - delta);
    float w = pow(cos(delta * NumSectors / 2), q); // シャープネス制御
    return max(w, 0.0);
}

[numthreads(8, 8, 1)]
void AIKuwaharaCS(uint3 DTid : SV_DispatchThreadID)
{
    float2 uv = (DTid.xy + 0.5) / ImageSize;
    float2 center = uv * ImageSize;

    float4 accumColor = float4(0, 0, 0, 0);
    float accumWeight = 0.0;

    for (int dy = -Radius; dy <= Radius; dy++)
    {
        for (int dx = -Radius; dx <= Radius; dx++)
        {
            float2 offset = float2(dx, dy);
            float2 sampleUV = (center + offset) / ImageSize;

            float2 rotated = Rotate(offset, -Angle);
            rotated.x /= EllipseA.x;
            rotated.y /= EllipseA.y;

            if (dot(rotated, rotated) <= 1.0)
            {
                float sectorAngle = atan2(offset.y, offset.x);
                float weight = 0.0;

                for (int i = 0; i < NumSectors; i++)
                {
                    float angle = (2 * PI / NumSectors) * i;
                    weight += SectorWeight(offset, angle, 2 * PI / NumSectors, Q);
                }

                float4 color = InputTex.SampleLevel(samplerLinearClamp, sampleUV, 0);
                accumColor += color * weight;
                accumWeight += weight;
            }
        }
    }

    OutputTex[DTid.xy] = accumColor / max(accumWeight, 1e-5);
}
